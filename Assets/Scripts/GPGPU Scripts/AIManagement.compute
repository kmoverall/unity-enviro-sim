// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ProcessCritters

struct CritterData {
	float health;
    float consumption;
    float timeDrain;
    float isAlive;
};

globallycoherent RWTexture2D<float4> EnergyField;
RWStructuredBuffer<CritterData> Data;
RWStructuredBuffer<float2> Positions;
StructuredBuffer<int> DrawArgs;

int2 Sim_EnergyFieldSize;
//x is the cap on energy in the field, y is the cap on critter energy
float2 Sim_EnergyCaps;
float Unity_DeltaTime;

float rand_1(in float2 uv)
{
	float noise = (frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453));
	return noise;
}
float2 rand_2(in float2 uv)
{
    float noiseX = (frac(sin(dot(uv, float2(12.9898,78.233)      )) * 43758.5453));
    float noiseY = (frac(sin(dot(uv, float2(12.9898,78.233) * 2.0)) * 43758.5453));
    return float2(noiseX, noiseY);
}

int2 rand_max_position(int2 a, int2 b, float2 seed)
{
	
	float x = EnergyField[a].r;
	float y = EnergyField[b].r;

	if (x > y)
	{
		return a;
	}
	else if (x < y)
	{ 
		return b;
	}
	else
	{
		float coinFlip = round(rand_1(seed));
		return coinFlip * a + (1-coinFlip) * b;
	}
}

float2 DecideDirection(float2 pos, int2 iPos)
{
	int2 sample_L = iPos.x > 0 ? int2(-1, 0) : int2(0, 0);
	int2 sample_R = iPos.x < Sim_EnergyFieldSize.x - 1 ? int2(1, 0) : int2(0, 0);
	int2 sample_D = iPos.y > 0 ? int2(0, -1) : int2(0, 0);
	int2 sample_U = iPos.y < Sim_EnergyFieldSize.y - 1 ? int2(0, 1) : int2(0, 0);

	int2 newPos = rand_max_position(iPos, iPos + sample_L, pos);
	newPos = rand_max_position(newPos, iPos + sample_R, pos + float2(1,0));
	newPos = rand_max_position(newPos, iPos + sample_D, pos + float2(2, 0));
	newPos = rand_max_position(newPos, iPos + sample_U, pos + float2(3, 0));
	newPos = rand_max_position(newPos, iPos + sample_R + sample_U, pos + float2(4, 0));
	newPos = rand_max_position(newPos, iPos + sample_L + sample_U, pos + float2(5, 0));
	newPos = rand_max_position(newPos, iPos + sample_R + sample_D, pos + float2(6, 0));
	newPos = rand_max_position(newPos, iPos + sample_L + sample_D, pos + float2(7, 0));

	return newPos - iPos;
}

[numthreads(1024,1,1)]
void ProcessCritters (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= DrawArgs[0]) {
		return;
	}

	if (!Data[id.x].isAlive) {
		return;
	}

	float2 pos = Positions[id.x];
	int2 iPos;
	iPos = round(pos - 0.5) + (Sim_EnergyFieldSize.xy / 2);

	float2 direction = DecideDirection(pos, iPos);
	pos += direction * Unity_DeltaTime;
	pos = clamp(pos, -Sim_EnergyFieldSize/2.0f, Sim_EnergyFieldSize/2.0f);
	iPos = round(pos - 0.5) + (Sim_EnergyFieldSize.xy / 2);

	CritterData specs = Data[id.x];

	float energyGain = min(EnergyField[iPos].r, specs.consumption * Unity_DeltaTime);
	EnergyField[iPos] -= energyGain;
	specs.health += energyGain;
	specs.health -= specs.timeDrain * Unity_DeltaTime;
	specs.health = clamp(specs.health, 0, Sim_EnergyCaps.y);

	if (specs.health == 0)
		specs.isAlive = 0;

	Data[id.x] = specs;
	Positions[id.x] = pos;
}
