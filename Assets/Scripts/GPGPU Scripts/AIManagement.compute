// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ProcessCritters

struct CritterData {
	float health;
    float consumption;
    float timeDrain;
    float isAlive;
};

globallycoherent RWTexture2D<float4> EnergyField;
RWStructuredBuffer<CritterData> Data;
RWStructuredBuffer<float2> Positions;
StructuredBuffer<int> DrawArgs;

int2 Sim_EnergyFieldSize;
//x is the cap on energy in the field, y is the cap on critter energy
float2 Sim_EnergyCaps;
float Unity_DeltaTime;

float2 rand_2(in float2 uv)
{
    float noiseX = (frac(sin(dot(uv, float2(12.9898,78.233)      )) * 43758.5453));
    float noiseY = (frac(sin(dot(uv, float2(12.9898,78.233) * 2.0)) * 43758.5453));
    return float2(noiseX, noiseY);
}

float2 DecideDirection(float2 pos, int2 iPos)
{
	int2 sample_L = iPos.x > 0 ? int2(-1, 0) : int2(0, 0);
	int2 sample_R = iPos.x < Sim_EnergyFieldSize.x - 1 ? int2(1, 0) : int2(0, 0);
	int2 sample_D = iPos.x > 0 ? int2(0, -1) : int2(0, 0);
	int2 sample_U = iPos.x < Sim_EnergyFieldSize.x - 1 ? int2(0, 1) : int2(0, 0);

	float2 gradient;

	gradient.x = 2 * EnergyField[iPos + sample_R].r + EnergyField[iPos + sample_R + sample_U].r + EnergyField[iPos + sample_R + sample_D].r;
	gradient.x -= 2 * EnergyField[iPos + sample_L].r + EnergyField[iPos + sample_L + sample_U].r + EnergyField[iPos + sample_L + sample_D].r;

	gradient.y = 2 * EnergyField[iPos + sample_U].r + EnergyField[iPos + sample_U + sample_R].r + EnergyField[iPos + sample_D + sample_L].r;
	gradient.y -= 2 * EnergyField[iPos + sample_D].r + EnergyField[iPos + sample_D + sample_R].r + EnergyField[iPos + sample_D + sample_L].r;

	if (!any(gradient))
		gradient = rand_2(pos);
	gradient = normalize(gradient);

	return gradient;
}

float ShouldMove(float2 pos, int2 iPos)
{
	int2 sample_L = iPos.x > 0 ? int2(-1, 0) : int2(0, 0);
	int2 sample_R = iPos.x < Sim_EnergyFieldSize.x - 1 ? int2(1, 0) : int2(0, 0);
	int2 sample_D = iPos.x > 0 ? int2(0, -1) : int2(0, 0);
	int2 sample_U = iPos.x < Sim_EnergyFieldSize.x - 1 ? int2(0, 1) : int2(0, 0);

	float maxNeighbor = EnergyField[iPos + sample_R].r;
	maxNeighbor = max(maxNeighbor, EnergyField[iPos + sample_L].r);
	maxNeighbor = max(maxNeighbor, EnergyField[iPos + sample_U].r);
	maxNeighbor = max(maxNeighbor, EnergyField[iPos + sample_D].r);
	maxNeighbor = max(maxNeighbor, EnergyField[iPos + sample_U + sample_R].r);
	maxNeighbor = max(maxNeighbor, EnergyField[iPos + sample_U + sample_L].r);
	maxNeighbor = max(maxNeighbor, EnergyField[iPos + sample_D + sample_R].r);
	maxNeighbor = max(maxNeighbor, EnergyField[iPos + sample_D + sample_L].r);
	
	float result = (maxNeighbor - EnergyField[iPos].r) / Sim_EnergyCaps.x;
	return result * 0.5 + 0.5;
}

[numthreads(1024,1,1)]
void ProcessCritters (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= DrawArgs[0]) {
		return;
	}

	if (!Data[id.x].isAlive) {
		return;
	}

	float2 pos = Positions[id.x];
	int2 iPos;
	iPos = round(pos - 0.5) + (Sim_EnergyFieldSize.xy / 2);

	float2 direction = DecideDirection(pos, iPos);
	float moveMod = ShouldMove(pos, iPos);
	direction *= pow(abs(moveMod), 0.5f); 

	pos += direction * Unity_DeltaTime;
	pos = clamp(pos, -Sim_EnergyFieldSize/2.0f, Sim_EnergyFieldSize/2.0f);
	iPos = round(pos - 0.5) + (Sim_EnergyFieldSize.xy / 2);

	CritterData specs = Data[id.x];

	float energyGain = min(EnergyField[iPos].r, specs.consumption * Unity_DeltaTime);
	EnergyField[iPos] -= energyGain;
	specs.health += energyGain;
	specs.health -= specs.timeDrain * Unity_DeltaTime;
	specs.health = clamp(specs.health, 0, Sim_EnergyCaps.y);

	if (specs.health == 0)
		specs.isAlive = 0;

	Data[id.x] = specs;
	Positions[id.x] = pos;
}
